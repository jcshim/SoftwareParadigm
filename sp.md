# 소프트웨어 개발 패러다임

* 패러다임의 정의: 바라보는 시각, 뷰, 관점.
* 소프트웨어 개발 페러다임: 소프트웨어 개발에 대한 견해
* 소프트웨어 개발 패러다임의 변화로 소프트웨어의 개발 비용, 품질, 유지보수에 많은 변화를 가져왔고 지속적으로 변화를 가져온다.

# 소프트웨어 개발 방법론
* 구조적 방법론
* 정보공학 방법론
* 객체지향 방법론
* 컴포넌트 기반 방법론
* 서비스지향 방법론

# 절차지향 패러다임
* SW 개발에 있는 기능중심, 절차중심의 관점에서 개발하는 방식
* SW 공학에서는 이를 구조적 개발방식
* 1970년~1980년 초반까지 SW 개발이 있어서 주류를 이루었던 패러다임
* 소프트웨어 재사용이나 SW 유지보수에 있어서 많은 한계점 드러남
* 기능 또는 함수 중심으로 SW를 개발하기 때문에 데이터들이 지역화(Localization)가 되지 않고 전역화(Globalization)되어, 개발과정이나 개발이후에 특정 데이터를 변경(타입변경, 변수명변경 등)하거나 함수를 변경하면 전체 프로그램에 영향을 미쳐서 변경이 매우 어렵다.

# 객체지향 패러다임
* 절차지향으로 개발된 프로그램에는 데이터와 함수들이 서로 연관되어 있지 않고, 데이터와 함수들이 분산되어 있다.
* 데이터와 함수들이 독립적인 것처럼 취급되기 때문에 프로그램의 복잡도는 높아지고 프로그램의 모듈성은 매우 떨어짐.
* 문제점을 해결 위해 객제지향 패러다임이 등장.
* 분산되어 있던 데이터와 함수를 독립적인 모듈 단위인 객체 단위로 그룹핑해서 프로그램을 구성하는 패러다임.
* 하나의 소프트웨어는 객체들의 집합으로 이루어져 있으며, 각각의 객체 속에는 관련된 데이터와 함수들이 포함되어 있다.
* 특정 데이터의 변경이나 함수의 변경이 전체 프로그램에 영향을 미치는 것이 아니라 변경할 데이터나 함수가 존재하는 객체에만 영향을 미치게 되었다. 프로그램의 수정이 훨씬 쉽고, 모듈단위의 집합이기 때문에 모듈성 또한 향상됨.

# 객체지향 모델링
* 모델링
  * 모델을 만드는 작업으로서, 현실 세계를 단순화 시켜 표현하는 기법을 말한다.
  * 개발할 소프트웨어에 대한 모델 혹은 도면은 만드는 작업
* 소프트웨어 개발 프로세스(공정)을 6단계로 구분
  * 계획 -> 분석 -> 설계 -> 구현 -> 시험 -> 유지보수
* 분석과 설계를 모델링 단계라 부르며 수행하고 나면 개발할 소프트웨어에 대한 다양한 산출물들이 나오는데 이 산출물들을 모델들이라고 부른다.
* 이 모델에 대한 형태는 다이어그램 형태, 명세서와 같은 스펙(specification)이나 프로토타입(Prototype)이 될 수 있으며, 이는 모델을 만드는 모델링 기법에 따라 다양하다.

* 모델링의 중요성
  * 모델링을 하는 목적은 개발할 시스템의 범위나 구조 또는 기능들을 보다 용이하게 이해하기 위함.
  * 시스템 개발에 있어서 개발할 시스템 도메인에 대한 이해가 무엇보다 중요.
* 모델링의 목표
  * 모델링의 목적은 개발할 실세계의 도메인의 복잡한 내용들을 단순화시킴으로써 도메인에 대해 보다 정확한 이해하기 위함.
* 원칙
  1 해당 실세계 도메인을 잘 반영할 수 있는 모델을 선택해야 한다.
    - 실세계 현상을 단순화시키는 작업으로 개발할 도메인과 잘 연결할 수 잇는 모델을 선택하여 모델링
  2 여러 다양한 각도에서 표현할 수 있는 모델들을 만들어야 한다.
    - 하나의 모델을 가지고 그 시스템의 모든 구조, 행위, 상태, 작업 흐름들을 다 표혀하기 불가능하다.
    - 하나의 모델이 아닌 시스템의 구조척 측면, 기능적 측면, 동적 측면 등 다양한 관점에서 관점별로 모델들을 개발해야 해당 도메인에 대한 정확하게 파악할 수 있다.
  3 개발할 시스템에 적합한 모델을 선택해야 한다.
    - 시스템에 따라 해당 시스템이 직면하게 될 공격의 형태가 다양하고, 또한 이러한 공격에 대한 해결 형태 또한 다양할 수 있다.
    - 어떤 모델을 선택하느냐에 따라 개발할 시스템이 봉착하게될 문제점이나 해결안의 표현이 쉽거나 어려워질수 있다.

* 모델링 기대효과
  1 개발할 시스템을 가시화
    - 모델링을 통해 개발할 시스템의 기능이 어떤 것들인지, 시스템의내부 구조는 어떻게 형성되는지 등등 다양한 형태의 모델들을 통해 개발될 시스템의 형태를 가시적으로 보여줄 수 있게 된다.
  2 개발할 시스템에 대해 명세화
    - 소프트웨어의 구조에 대한 명세화, 기능에 대한 명세화, 워크 플로우에 대한 명세화, 상태 평세화 등등 다양한 명세화를 모델링을 통해 할 수 있다. 이러한 명세화를 통해 개발 시스템의 범위를 보다 정확히 이해할 수 있다.
  3 개발할 시스템 구축에 대한 기초를 마련
    - 구현단계에 들어가기 위해서는 모델링 단계의 산출물이 입력물로 사용된다.
    - 따라서 모델의 산출물이 구현을 위한 기반을 마련하는 것
    - 설계단계의 산출물을 가지고 CASE 도구에서 소스코드 생성 기능을 통해 개발할 언어에 따른 템플릿 코드까지 자동생성하여
    - 개발자는 함수의 로직이나 일부 내용만 수정하면 되기 때문에 구현이 보다 빨리 이루어진다.
* 객제지향 언어
  * 클래스
    - 클래스를 구성하는 속성, 클래스의 행위 또는 기능을 멤버함수 형태로 제공
    - 각각의 변수나 함수들에 대해 정보은닉 장치로 private, protected, public등의 접근 권한자
  * 객체
    - 클래스로부터 객체를 생성
    - new 연산자, 객체 생성함수 또는 생성자를 통해 객체 생성
    - 생성된 객체 단위로 특정 객체에 서비스를 요청하는 메서지를 전송
  * 상속
    - extends를 통해서 일반 클래스간의 상속관계
    - 추상클래스와 일반클래스 간의 상속관계
    - 인터페이스 간의 상속관계
    - 상속 관계를 통해 함수 오버로딩, 함수 오버라이딩
  * 추상클래스
    - 클래스 명 앞에 abstract 키워드 선언
    - 추상 클래스 내의 추상함수를 표현으로 함수명 앞에 abstract 구분
    - 상속관계에 있는 하위 클래스들에서 이 추상 함수를 구현함으로써 오버로딩을 구현할 수 있도록 하고 있다.
  * 인터페이스
    - 함수들의 집합
    - 인터페이스에 선언된 함수들은 모두 클래스를 통해서만 구현할 수 있도록 하고 있다.
    - 클래스와 인터페이스 간의 관계는 상속이 아닌 구현으로서 '클래스 implements 인터페이스' 구현
  * 컴포넌트
    - JavaBean과 EJB(Enterprise Java Bean)라는 2개의 기술 플랫폼을 통해 컴포넌트를 구현할 수 있는 장치를 제공
    - 컴포넌트 개념들을 반영하여 인터페이스와 인터페이스글 구현하는 컴포넌트 클래스 등에 대한 규약들을 지정하고 있다.
    - 비즈니스 컴포넌트 개발을 위한 EJB 컴포넌트에서는 모든 EJB 컴포넌트는 반드시 홈 인터페이스(Home Interface)와 원격인터페이스(Remote Interface) 또는 로컬 인터페이스(Local Interface)를 정의하도록 명시
    - 컴포넌트 구현 장치로 빈 클래스 형태로 구현하도록 명시
    - 컴포넌트를 서버에 배치하기 위해서는 디플로이먼트 디스크립터(Deployment Descriptor)라는 파일에 배치할 컴포넌트들에 대한 명세를 정의하도록 하고 있다.

[1] 출처-UML과 JAVA로 배우는 객체지향 설계 및 구현 <br>
[2] https://frontierdev.tistory.com/91
